import {
    StripeTransactionPlanStep,
    TransactionPlan,
    TransactionPlanStep
} from "../../lambdas/rest/transactions/TransactionPlan";
import {StripeUpdateChargeParams} from "./StripeUpdateChargeParams";
import {StripeRestError} from "./StripeRestError";
import {LightrailAndMerchantStripeConfig} from "./StripeConfig";
import {StripeTransactionParty} from "../../model/TransactionRequest";
import {TransactionPlanError} from "../../lambdas/rest/transactions/TransactionPlanError";
import {StripeCreateChargeParams} from "./StripeCreateChargeParams";
import * as giftbitRoutes from "giftbit-cassava-routes";
import log = require("loglevel");
import Stripe = require("stripe");
import IRefund = Stripe.refunds.IRefund;
import ICharge = Stripe.charges.ICharge;

export async function createStripeCharge(params: StripeCreateChargeParams, lightrailStripeSecretKey: string, merchantStripeAccountId: string, stepIdempotencyKey: string): Promise<ICharge> {
    const lightrailStripe = require("stripe")(lightrailStripeSecretKey);
    // params.description = "Lightrail Checkout transaction.";  // todo what is this
    log.info(`Creating Stripe charge ${JSON.stringify(params)}.`);

    let charge: ICharge;
    try {
        charge = await lightrailStripe.charges.create(params, {
            stripe_account: merchantStripeAccountId,
            idempotency_key: stepIdempotencyKey
        });
    } catch (err) {
        log.warn(`Error charging Stripe: ${err}`);

        switch (err.type) {
            case "StripeIdempotencyError":
                throw new StripeRestError(err.statusCode, `Stripe idempotency error: a charge already exists in Stripe with the idempotency key '${err.headers["idempotency-key"]}'. This key was generated by Lightrail from the checkout transaction ID for the charge '${JSON.stringify(params)}'.`, "StripeIdempotencyError", err);

            case "StripeCardError":
                if (err.raw.decline_code && err.raw.decline_code === "fraudulent") {
                    throw new StripeRestError(err.statusCode, "Card declined.", "StripeCardDeclinedFraudulent", err);
                }
                throw new StripeRestError(err.statusCode, "Card declined.", "StripeCardDeclined", err);

            case "StripeInvalidRequestError":
                if (err.code === "amount_too_small") {
                    throw new StripeRestError(err.statusCode, `Failed to charge credit card: amount '${params.amount}' for Stripe was too small.`, "StripeAmountTooSmall", err);
                }
                throw new StripeRestError(err.statusCode, "The stripeCardToken was invalid.", "StripeInvalidRequestError", err);

            case "RateLimitError":
                throw new StripeRestError(err.statusCode, `Service was rate limited by dependent service.`, "DependentServiceRateLimited", err); // technically this is up to us to handle once we're past mvp stage: since we are sending the requests, we should take responsibility for spacing & retrying

            default:
                throw new Error(`An unexpected error occurred while attempting to charge card. error ${err}`);
        }
    }
    log.info(`Created Stripe charge '${charge.id}'`);
    return charge;
}

export async function rollbackStripeSteps(lightrailStripeSecretKey: string, merchantStripeAccountId: string, steps: StripeTransactionPlanStep[], reason: string): Promise<void> {
    for (const step of steps) {
        const refund = await createRefund(step, lightrailStripeSecretKey, merchantStripeAccountId, reason);
        log.info(`Refunded Stripe charge ${step.chargeResult.id}. Refund: ${JSON.stringify(refund)}.`);
    }
}

export async function createRefund(step: StripeTransactionPlanStep, lightrailStripeSecretKey: string, merchantStripeAccountId: string, reason?: string): Promise<IRefund> {
    const lightrailStripe = require("stripe")(lightrailStripeSecretKey);
    log.info(`Creating refund for Stripe charge ${step.chargeResult.id}.`);
    const refund = await lightrailStripe.refunds.create({
        charge: step.chargeResult.id,
        metadata: {reason: reason || "not specified"} /* Doesn't show up in charge in stripe. Need to update charge so that it's obvious as to why it was refunded. */
    }, {
        stripe_account: merchantStripeAccountId
    });
    await updateCharge(step.chargeResult.id, {
        description: reason
    }, lightrailStripeSecretKey, merchantStripeAccountId);
    log.info(`Created Stripe refund for charge ${step.chargeResult.id}: ${refund}`);
    return refund;
}

export async function updateCharge(chargeId: string, params: StripeUpdateChargeParams, lightrailStripeSecretKey: string, merchantStripeAccountId: string): Promise<any> {
    const merchantStripe = require("stripe")(lightrailStripeSecretKey);
    log.info(`Updating Stripe charge ${JSON.stringify(params)}.`);
    const chargeUpdate = await merchantStripe.charges.update(
        chargeId,
        params, {
            stripe_account: merchantStripeAccountId,
        }
    );
    // todo make this a DTO.
    log.info(`Updated Stripe charge ${JSON.stringify(chargeUpdate)}.`);
    return chargeUpdate;
}


export async function chargeStripeSteps(auth: giftbitRoutes.jwtauth.AuthorizationBadge, stripeConfig: LightrailAndMerchantStripeConfig, plan: TransactionPlan) {
    const stripeSteps = plan.steps.filter(step => step.rail === "stripe") as StripeTransactionPlanStep[];

    try {
        for (let step of stripeSteps) {
            const stepForStripe = stripeTransactionPlanStepToStripeRequest(auth, step, plan);

            const charge = await createStripeCharge(stepForStripe, stripeConfig.lightrailStripeConfig.secretKey, stripeConfig.merchantStripeConfig.stripe_user_id, step.idempotentStepId);

            // Update transaction plan with charge details
            step.chargeResult = charge;
            // trace back to the requested payment source that lists the right 'source' and/or 'customer' param
            if (plan.paymentSources) {
                let stepSource = plan.paymentSources.find(
                    source => source.rail === "stripe" &&
                        (step.source ? source.source === step.source : true) &&
                        (step.customer ? source.customer === step.customer : true)
                ) as StripeTransactionParty;
                stepSource.chargeId = charge.id;
            }
        }
        // await doFraudCheck(lightrailStripeConfig, merchantStripeConfig, params, charge, evt, auth);
    } catch (err) {
        // todo: differentiate between stripe errors / db step errors, and fraud check errors once we do fraud checking: rollback if appropriate & make sure message is clear
        if ((err as StripeRestError).additionalParams.stripeError) {
            throw err;
        } else {
            throw new TransactionPlanError(`Transaction execution canceled because there was a problem charging Stripe: ${err}`, {
                isReplanable: false
            });
        }
    }
}

function stripeTransactionPlanStepToStripeRequest(auth: giftbitRoutes.jwtauth.AuthorizationBadge, step: StripeTransactionPlanStep, plan: TransactionPlan): StripeCreateChargeParams {
    let stepForStripe: StripeCreateChargeParams = {
        amount: -step.amount /* Lightrail treats debits as negative amounts on Steps but Stripe requires a positive amount when charging a credit card. */,
        currency: plan.currency,
        metadata: {
            ...plan.metadata,
            lightrailTransactionId: plan.id,
            lightrailTransactionSources: JSON.stringify(plan.steps.reduce(reducePaymentSourcesForStripeMetadata(step), [])),
            lightrailUserId: auth.giftbitUserId
        }
    };
    if (step.source) {
        stepForStripe.source = step.source;
    }
    if (step.customer) {
        stepForStripe.customer = step.customer;
    }

    log.debug("Created stepForStripe: \n" + JSON.stringify(stepForStripe, null, 4));
    return stepForStripe;
}

/**
 * Returned function compares a TransactionPlanStep to the current StripeStep being processed:
 * skip if they're the same thing, otherwise add identifying details to the results array
 */
function reducePaymentSourcesForStripeMetadata(currentStep: StripeTransactionPlanStep) {
    return (results: Array<any>, step: TransactionPlanStep) => {
        if (step.rail === "stripe" && step.idempotentStepId === currentStep.idempotentStepId) {
            return results;
        }
        switch (step.rail) {
            case "lightrail":
                results.push({
                    rail: "lightrail",
                    valueId: step.value.id
                });
                return results;
            case "internal":
                results.push({
                    rail: "internal",
                    internalId: step.internalId
                });
                return results;
            case "stripe":
                let stripeStep = {rail: "stripe"};
                if (step.source) {
                    (stripeStep as any).source = step.source;
                }
                if (step.customer) {
                    (stripeStep as any).customer = step.customer;
                }
                results.push(stripeStep);
                return results;
        }
    };
}
