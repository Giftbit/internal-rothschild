import {StripeRestError} from "./StripeRestError";
import * as giftbitRoutes from "giftbit-cassava-routes";
import {stripeApiVersion} from "./StripeConfig";
import * as cassava from "cassava";
import log = require("loglevel");
import Stripe = require("stripe");

export async function createCharge(params: Stripe.charges.IChargeCreationOptions, lightrailStripeSecretKey: string, merchantStripeAccountId: string, stepIdempotencyKey: string): Promise<Stripe.charges.ICharge> {
    const lightrailStripe = new Stripe(lightrailStripeSecretKey);
    lightrailStripe.setApiVersion(stripeApiVersion);
    log.info("Creating Stripe charge", params);

    try {
        const charge = await lightrailStripe.charges.create(params, {
            stripe_account: merchantStripeAccountId,
            idempotency_key: stepIdempotencyKey
        });
        log.info(`Created Stripe charge '${charge.id}'`);
        return charge;
    } catch (err) {
        log.warn("Error charging Stripe:", err);

        checkForStandardStripeErrors(err);
        switch (err.type) {
            case "StripeIdempotencyError":
                throw new StripeRestError(cassava.httpStatusCode.clientError.CONFLICT, `Stripe idempotency error: a charge already exists in Stripe with the idempotency key '${err.headers["idempotency-key"]}'. This key was generated by Lightrail from the checkout transaction ID for the charge '${JSON.stringify(params)}'.`, "StripeIdempotencyError", err);
            case "StripeCardError":
                throw new StripeRestError(cassava.httpStatusCode.clientError.CONFLICT, "Card declined.", "StripeCardDeclined", err);
            case "StripeInvalidRequestError":
                if (err.code === "amount_too_small") {
                    throw new StripeRestError(cassava.httpStatusCode.clientError.UNPROCESSABLE_ENTITY, `Failed to charge credit card: amount '${params.amount}' for Stripe was too small.`, "StripeAmountTooSmall", err);
                }
                throw new StripeRestError(cassava.httpStatusCode.clientError.CONFLICT, "The stripeCardToken was invalid.", "StripeInvalidRequestError", err);
            default:
                throw err;
        }
    }
}

export async function createRefund(params: Stripe.refunds.IRefundCreationOptionsWithCharge, lightrailStripeSecretKey: string, merchantStripeAccountId: string): Promise<Stripe.refunds.IRefund> {
    const lightrailStripe = new Stripe(lightrailStripeSecretKey);
    lightrailStripe.setApiVersion(stripeApiVersion);
    log.info("Creating refund for Stripe charge", params.charge);
    try {
        const refund = await lightrailStripe.refunds.create(params, {
            stripe_account: merchantStripeAccountId
        });
        log.info("Created Stripe refund for charge", params.charge, refund);
        return refund;
    } catch (err) {
        log.warn("Error refunding Stripe:", err);

        checkForStandardStripeErrors(err);
        if ((err as Stripe.IStripeError).code === "charge_already_refunded") {
            // Refunds are sorted most recent first, so we only need one.
            const refunds = await lightrailStripe.charges.listRefunds(params.charge, {limit: 1});
            if (refunds.data.length === 0) {
                throw new Error(`Attempting to refund charge '${params.charge}' resulted in 'charge_already_refunded' but listing refunds returned nothing.`);
            } else {
                return refunds.data[0];
            }
        }

        giftbitRoutes.sentry.sendErrorNotification(err);
        throw err;
    }
}

export async function captureCharge(chargeId: string, options: Stripe.charges.IChargeCaptureOptions, lightrailStripeSecretKey: string, merchantStripeAccountId: string): Promise<Stripe.charges.ICharge> {
    const lightrailStripe = new Stripe(lightrailStripeSecretKey);
    lightrailStripe.setApiVersion(stripeApiVersion);
    log.info("Creating capture for Stripe charge", chargeId);
    try {
        const capturedCharge = await lightrailStripe.charges.capture(chargeId, options, {
            stripe_account: merchantStripeAccountId
        });
        log.info("Created Stripe capture for charge", chargeId, capturedCharge);
        return capturedCharge;
    } catch (err) {
        log.warn("Error capturing Stripe charge:", err);

        checkForStandardStripeErrors(err);
        if ((err as Stripe.IStripeError).code === "charge_already_captured") {
            return await lightrailStripe.charges.retrieve(chargeId);
        }
        if ((err as Stripe.IStripeError).code === "charge_already_refunded") {
            throw new StripeRestError(409, `Stripe charge '${chargeId}' cannot be captured because it was refunded.`, "StripeChargeAlreadyRefunded", err);
        }

        giftbitRoutes.sentry.sendErrorNotification(err);
        throw err;
    }
}

export async function updateCharge(chargeId: string, params: Stripe.charges.IChargeUpdateOptions, lightrailStripeSecretKey: string, merchantStripeAccountId: string): Promise<any> {
    const lightrailStripe = new Stripe(lightrailStripeSecretKey);
    lightrailStripe.setApiVersion(stripeApiVersion);
    log.info("Updating Stripe charge", params);
    try {
        const chargeUpdate = await lightrailStripe.charges.update(
            chargeId,
            params, {
                stripe_account: merchantStripeAccountId,
            }
        );
        log.info("Updated Stripe charge", chargeUpdate);
        return chargeUpdate;
    } catch (err) {
        checkForStandardStripeErrors(err);
        log.warn("Error updating Stripe charge:", err);
        giftbitRoutes.sentry.sendErrorNotification(err);
        throw err;
    }
}

function checkForStandardStripeErrors(err: any): void {
    switch (err.type) {
        case "RateLimitError":
            throw new StripeRestError(429, `Service was rate limited by dependent service.`, "DependentServiceRateLimited", err); // technically this is up to us to handle once we're past mvp stage: since we are sending the requests, we should take responsibility for spacing & retrying
        case "StripePermissionError":
            throw new StripeRestError(424, "Application access may have been revoked. .", "StripePermissionError", err);
        default:
        // do nothing
    }
}
