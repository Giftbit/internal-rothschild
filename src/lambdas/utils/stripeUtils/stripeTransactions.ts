import {httpStatusCode} from "cassava";
import {StripeTransactionPlanStep} from "../../rest/transactions/TransactionPlan";
import {StripeUpdateChargeParams} from "./StripeUpdateChargeParams";
import {StripeRestError} from "./StripeRestError";
import log = require("loglevel");
import Stripe = require("stripe");
import ICharge = Stripe.charges.ICharge;
import IRefund = Stripe.refunds.IRefund;

export async function createStripeCharge(params: any, lightrailStripeSecretKey: string, merchantStripeAccountId: string, stepIdempotencyKey: string): Promise<ICharge> {
    const lightrailStripe = require("stripe")(lightrailStripeSecretKey);
    // params.description = "Lightrail Checkout transaction.";  // todo what is this
    log.info(`Creating transaction ${JSON.stringify(params)}.`);

    let charge: ICharge;
    try {
        charge = await lightrailStripe.charges.create(params, {
            stripe_account: merchantStripeAccountId,
            idempotency_key: stepIdempotencyKey
        });
    } catch (err) {
        switch (err.type) {
            case "StripeIdempotencyError":
                throw new StripeRestError(err.statusCode, `Stripe idempotency error: a charge already exists in Stripe with the idempotency key '${err.headers["idempotency-key"]}'. This key was generated by Lightrail from the checkout transaction ID for the charge '${JSON.stringify(params)}'.`, "StripeIdempotencyError", err);
            case "StripeCardError":
                throw new StripeRestError(httpStatusCode.clientError.BAD_REQUEST, "Failed to charge credit card.", "ChargeFailed", err);
            case "StripeInvalidRequestError":
                throw new StripeRestError(httpStatusCode.clientError.BAD_REQUEST, "The stripeCardToken was invalid.", "StripeInvalidRequestError", err);
            case "RateLimitError":
                throw new StripeRestError(httpStatusCode.clientError.TOO_MANY_REQUESTS, `Service was rate limited by dependent service.`, "DependentServiceRateLimited", err); // technically this is up to us to handle once we're past mvp stage: since we are sending the requests, we should take responsibility for spacing & retrying
            default:
                throw new Error(`An unexpected error occurred while attempting to charge card. error ${err}`);
        }
    }
    log.info(`Created charge ${JSON.stringify(charge)}`); // todo is this safe to log?
    return charge;
}

export async function rollbackStripeStep(lightrailStripeSecretKey: string, merchantStripeAccountId: string, step: StripeTransactionPlanStep, reason: string): Promise<void> {
    const refund = await createRefund(step, lightrailStripeSecretKey, merchantStripeAccountId, reason);
    log.info(`Refunded charge ${step.chargeResult.id}. Refund: ${JSON.stringify(refund)}.`);
}

export async function createRefund(step: StripeTransactionPlanStep, lightrailStripeSecretKey: string, merchantStripeAccountId: string, reason?: string): Promise<IRefund> {
    const lightrailStripe = require("stripe")(lightrailStripeSecretKey);
    log.info(`Creating refund for charge ${step.chargeResult.id}.`);
    const refund = await lightrailStripe.refunds.create({
        charge: step.chargeResult.id,
        metadata: {reason: reason || "not specified"} /* Doesn't show up in charge in stripe. Need to update charge so that it's obvious as to why it was refunded. */
    }, {
        stripe_account: merchantStripeAccountId
    });
    await updateCharge(step.chargeResult.id, {
        description: reason
    }, lightrailStripeSecretKey, merchantStripeAccountId);
    log.info(JSON.stringify(refund));
    return refund;
}

export async function updateCharge(chargeId: string, params: StripeUpdateChargeParams, lightrailStripeSecretKey: string, merchantStripeAccountId: string): Promise<any> {
    const merchantStripe = require("stripe")(lightrailStripeSecretKey);
    log.info(`Updating charge ${JSON.stringify(params)}.`);
    const chargeUpdate = await merchantStripe.charges.update(
        chargeId,
        params, {
            stripe_account: merchantStripeAccountId,
        }
    );
    // todo make this a DTO.
    log.info(`Updated charge ${JSON.stringify(chargeUpdate)}.`);
    return chargeUpdate;
}



